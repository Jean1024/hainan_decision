(function() {
	var platform = process.platform;
	platform = /^win/.test(platform)? 'win' : /^darwin/.test(platform)? 'mac' : 'linux' + (process.arch == 'ia32' ? '32' : '64');
	var platform_detail = platform == 'win'?platform+(process.arch == 'ia32' ? '32' : '64'):'';
	

	var http_method = {
		'http:': require('http'),
		'https:': require('https')
	}
	var fs = require('fs');
	var path = require('path');
	var os = require('os');
	var URL = require('url');
	var crypto = require('crypto');
	var spawn = require('child_process').spawn;

	var encrypt = function(str, key){
		if(str && str.toString){
			return crypto.createHash('sha1').update(str.toString() + (key||'')).digest('hex');
		}
		return '';
	}
	var _fn_global;
	function Upgrade(conf, fn){
		this.conf = conf;
		_fn_global = fn;
	}
	Upgrade.prototype.check = function(cb) {
		var _this = this;
		var conf = _this.conf;
		var manifestUrl = conf.manifestUrl;
		if (manifestUrl) {
			var obj_url = URL.parse(manifestUrl);
			http_method[obj_url.protocol].get(manifestUrl, function(res) {
				var content = '';
				res.on('data', function(bf) {
					content += bf.toString();
				});
				res.on('end', function() {
					try {
						content = JSON.parse(content);

						_this.confNew = content;
						if (content.version != conf.version) {
							cb && cb(content.version);
						}
					} catch(e) {}
				});
			});
		}
	}
	Upgrade.prototype.download = function(opt) {
		var _this = this;
		var onprocess, onfinish;
		if (opt) {
			onprocess = opt.onprocess;
			onfinish = opt.onfinish;
		}

		var conf = _this.confNew;
		var packages = conf.packages;_fn_global(conf);
		if (packages) {
			var info = packages[platform] || packages[platform_detail];
			_fn_global(info);
			if (info) {
				var download_url = info.url;
				var size = info.size;
				var obj_url = URL.parse(download_url);
				console.log(download_url);
				http_method[obj_url.protocol].get(download_url, function(res) {
					var headers = res.headers;
					if (headers) {
						var contentLen = headers['content-length'];
						console.log('contentLen = '+contentLen);
						if (contentLen) {
							size = contentLen;
						}
					}
					size = size || 1024*1024*40;
					console.log('size = '+size);
					var name = path.basename(download_url);
					var tmpDir = os.tmpDir();
					var path_tmp = path.join(tmpDir, encrypt(download_url, conf.version));

					var file_tmp = fs.openSync(path_tmp, 'w');
					var pos = 0;
					res.on('data', function(bf) {
						var len = bf.length;
						fs.writeSync(file_tmp, bf, 0, len);
						pos += len;
						console.log(pos, size, pos/size);
						onprocess && onprocess(pos, size);
					});
					res.on('end', function() {
						fs.closeSync(file_tmp);

						var path_exec = path.join(tmpDir, name);
						if (fs.existsSync(path_exec)) {
							fs.unlinkSync(path_exec);
						}
						fs.renameSync(path_tmp, path_exec);


						_this.path_exec = path_exec;
						onfinish && onfinish(path_exec);
					});
				});
			}
		}
	}
	// Upgrade.prototype.install = function() {
	// 	var path_exec = this.path_exec;
	// 	if (path_exec) {
	// 		try{
	// 			require('nw.gui').Shell.openItem(path_exec);
	// 		} catch(e) {
	// 			require('electron').Shell.openItem(path_exec);
	// 		}
	// 		// console.log(path_exec, fs.existsSync(path_exec));

	// 		// // require('nw.gui').Shell.openItem(path_exec);
	// 		// // var sp = spawn(path_exec, ["UPGRADE"], {
	// 		// // 	// detached: true,
	// 		// // });
	// 		// // sp.unref();

	// 		// var cp = require('child_process').exec(path_exec+' UPGRADE', function() {
	// 		// 	console.log(arguments);
	// 		// });
	// 		// cp.unref();
	// 	}
	// }
	module.exports = Upgrade
})();